[ /Title (Programming Principles and Practice Using C++)
  /Author (Bjarne Stroustrup)

  [ /Title (Preface) /Page 25 /OUT pdfmark
  [ /Count -7 /Title (Chapter 0 Notes to the Reader) /Page 33 /OUT pdfmark
    [ /Count -3 /Title (0.1 The structure of this book) /Page 34 /OUT pdfmark
      [ /Title (0.1.1 General approach) /Page 35 /OUT pdfmark
      [ /Title (0.1.2 Drills, exercises, etc.) /Page 36 /OUT pdfmark
      [ /Title (0.1.3 What comes after this book?) /Page 37 /OUT pdfmark

    [ /Count -3 /Title (0.2 A philosophy of teaching and learning) /Page 38 /OUT pdfmark
      [ /Title (0.2.1 The order of topics) /Page 41 /OUT pdfmark
      [ /Title (0.2.2 Programming and programming language) /Page 42 /OUT pdfmark
      [ /Title (0.2.3 Portability) /Page 43 /OUT pdfmark

    [ /Title (0.3 Programming and computer science) /Page 44 /OUT pdfmark
    [ /Title (0.4 Creativity and problem solving) /Page 44 /OUT pdfmark
    [ /Title (0.5 Request for feedback) /Page 44 /OUT pdfmark
    [ /Title (0.6 References) /Page 45 /OUT pdfmark
    [ /Title (0.7 Biographies) /Page 45 /OUT pdfmark

  [ /Count -6 /Title (Chapter 1 Computers, People, and Programming) /Page 49 /OUT pdfmark
    [ /Title (1.1 Introduction) /Page 50 /OUT pdfmark
    [ /Title (1.2 Software) /Page 51 /OUT pdfmark
    [ /Title (1.3 People) /Page 53 /OUT pdfmark
    [ /Title (1.4 Computer science) /Page 56 /OUT pdfmark
    [ /Count -7 /Title (1.5 Computers are everywhere) /Page 57 /OUT pdfmark
      [ /Title (1.5.1 Screens and no screens) /Page 58 /OUT pdfmark
      [ /Title (1.5.2 Shipping) /Page 58 /OUT pdfmark
      [ /Title (1.5.3 Telecommunications) /Page 60 /OUT pdfmark
      [ /Title (1.5.4 Medicine) /Page 62 /OUT pdfmark
      [ /Title (1.5.5 Information) /Page 63 /OUT pdfmark
      [ /Title (1.5.6 A vertical view) /Page 65 /OUT pdfmark
      [ /Title (1.5.7 So what?) /Page 66 /OUT pdfmark

    [ /Title (1.6 Ideals for programmers) /Page 66 /OUT pdfmark

  [ /Count -8 /Title (Part I The Basics) /Page 73 /OUT pdfmark
    [ /Count -5 /Title (Chapter 2 Hello, World!) /Page 75 /OUT pdfmark
      [ /Title (2.1 Programs) /Page 76 /OUT pdfmark
      [ /Title (2.2 The classic first program) /Page 77 /OUT pdfmark
      [ /Title (2.3 Compilation) /Page 79 /OUT pdfmark
      [ /Title (2.4 Linking) /Page 83 /OUT pdfmark
      [ /Title (2.5 Programming environments) /Page 84 /OUT pdfmark

    [ /Count -9 /Title (Chapter 3 Objects, Types, and Values) /Page 91 /OUT pdfmark
      [ /Title (3.1 Input) /Page 92 /OUT pdfmark
      [ /Title (3.2 Variables) /Page 94 /OUT pdfmark
      [ /Title (3.3 Input and type) /Page 96 /OUT pdfmark
      [ /Title (3.4 Operations and operators) /Page 98 /OUT pdfmark
      [ /Count -1 /Title (3.5 Assignment and initialization) /Page 101 /OUT pdfmark
        [ /Title (3.5.1 An example: detect repeated words) /Page 103 /OUT pdfmark

      [ /Count -1 /Title (3.6 Composite assignment operators) /Page 105 /OUT pdfmark
        [ /Title (3.6.1 An example: find repeated words) /Page 105 /OUT pdfmark

      [ /Title (3.7 Names) /Page 106 /OUT pdfmark
      [ /Title (3.8 Types and objects) /Page 109 /OUT pdfmark
      [ /Count -2 /Title (3.9 Type safety) /Page 110 /OUT pdfmark
        [ /Title (3.9.1 Safe conversions) /Page 111 /OUT pdfmark
        [ /Title (3.9.2 Unsafe conversions) /Page 112 /OUT pdfmark


    [ /Count -7 /Title (Chapter 4 Computation) /Page 121 /OUT pdfmark
      [ /Title (4.1 Computation) /Page 122 /OUT pdfmark
      [ /Title (4.2 Objectives and tools) /Page 124 /OUT pdfmark
      [ /Count -3 /Title (4.3 Expressions) /Page 126 /OUT pdfmark
        [ /Title (4.3.1 Constant expressions) /Page 127 /OUT pdfmark
        [ /Title (4.3.2 Operators) /Page 129 /OUT pdfmark
        [ /Title (4.3.3 Conversions) /Page 131 /OUT pdfmark

      [ /Count -2 /Title (4.4 Statements) /Page 132 /OUT pdfmark
        [ /Title (4.4.1 Selection) /Page 134 /OUT pdfmark
        [ /Title (4.4.2 Iteration) /Page 141 /OUT pdfmark

      [ /Count -2 /Title (4.5 Functions) /Page 145 /OUT pdfmark
        [ /Title (4.5.1 Why bother with functions?) /Page 147 /OUT pdfmark
        [ /Title (4.5.2 Function declarations) /Page 149 /OUT pdfmark

      [ /Count -4 /Title (4.6 vector) /Page 149 /OUT pdfmark
        [ /Title (4.6.1 Traversing a vector) /Page 151 /OUT pdfmark
        [ /Title (4.6.2 Growing a vector) /Page 151 /OUT pdfmark
        [ /Title (4.6.3 A numeric example) /Page 152 /OUT pdfmark
        [ /Title (4.6.4 A text example) /Page 155 /OUT pdfmark

      [ /Title (4.7 Language features) /Page 157 /OUT pdfmark

    [ /Count -11 /Title (Chapter 5 Errors) /Page 165 /OUT pdfmark
      [ /Title (5.1 Introduction) /Page 166 /OUT pdfmark
      [ /Title (5.2 Sources of errors) /Page 168 /OUT pdfmark
      [ /Count -3 /Title (5.3 Compile-time errors) /Page 168 /OUT pdfmark
        [ /Title (5.3.1 Syntax errors) /Page 169 /OUT pdfmark
        [ /Title (5.3.2 Type errors) /Page 170 /OUT pdfmark
        [ /Title (5.3.3 Non-errors) /Page 171 /OUT pdfmark

      [ /Title (5.4 Link-time errors) /Page 171 /OUT pdfmark
      [ /Count -3 /Title (5.5 Run-time errors) /Page 172 /OUT pdfmark
        [ /Title (5.5.1 The caller deals with errors) /Page 174 /OUT pdfmark
        [ /Title (5.5.2 The callee deals with errors) /Page 175 /OUT pdfmark
        [ /Title (5.5.3 Error reporting) /Page 177 /OUT pdfmark

      [ /Count -4 /Title (5.6 Exceptions) /Page 178 /OUT pdfmark
        [ /Title (5.6.1 Bad arguments) /Page 179 /OUT pdfmark
        [ /Title (5.6.2 Range errors) /Page 180 /OUT pdfmark
        [ /Title (5.6.3 Bad input) /Page 182 /OUT pdfmark
        [ /Title (5.6.4 Narrowing errors) /Page 185 /OUT pdfmark

      [ /Title (5.7 Logic errors) /Page 186 /OUT pdfmark
      [ /Title (5.8 Estimation) /Page 189 /OUT pdfmark
      [ /Count -1 /Title (5.9 Debugging) /Page 190 /OUT pdfmark
        [ /Title (5.9.1 Practical debug advice) /Page 191 /OUT pdfmark

      [ /Count -1 /Title (5.10 Pre- and post-conditions) /Page 195 /OUT pdfmark
        [ /Title (5.10.1 Post-conditions) /Page 197 /OUT pdfmark

      [ /Title (5.11 Testing) /Page 198 /OUT pdfmark

    [ /Count -9 /Title (Chapter 6 Writing a Program) /Page 205 /OUT pdfmark
      [ /Title (6.1 A problem) /Page 206 /OUT pdfmark
      [ /Count -2 /Title (6.2 Thinking about the problem) /Page 207 /OUT pdfmark
        [ /Title (6.2.1 Stages of development) /Page 208 /OUT pdfmark
        [ /Title (6.2.2 Strategy) /Page 208 /OUT pdfmark

      [ /Count -5 /Title (6.3 Back to the calculator!) /Page 210 /OUT pdfmark
        [ /Title (6.3.1 First attempt) /Page 211 /OUT pdfmark
        [ /Title (6.3.2 Tokens) /Page 213 /OUT pdfmark
        [ /Title (6.3.3 Implementing tokens) /Page 215 /OUT pdfmark
        [ /Title (6.3.4 Using tokens) /Page 217 /OUT pdfmark
        [ /Title (6.3.5 Back to the drawing board) /Page 218 /OUT pdfmark

      [ /Count -2 /Title (6.4 Grammars) /Page 220 /OUT pdfmark
        [ /Title (6.4.1 A detour: English grammar) /Page 225 /OUT pdfmark
        [ /Title (6.4.2 Writing a grammar) /Page 226 /OUT pdfmark

      [ /Count -4 /Title (6.5 Turning a grammar into code) /Page 227 /OUT pdfmark
        [ /Title (6.5.1 Implementing grammar rules) /Page 228 /OUT pdfmark
        [ /Title (6.5.2 Expressions) /Page 229 /OUT pdfmark
        [ /Title (6.5.3 Terms) /Page 232 /OUT pdfmark
        [ /Title (6.5.4 Primary expressions) /Page 234 /OUT pdfmark

      [ /Title (6.6 Trying the first version) /Page 235 /OUT pdfmark
      [ /Title (6.7 Trying the second version) /Page 240 /OUT pdfmark
      [ /Count -3 /Title (6.8 Token streams) /Page 241 /OUT pdfmark
        [ /Title (6.8.1 Implementing Token_stream) /Page 243 /OUT pdfmark
        [ /Title (6.8.2 Reading tokens) /Page 244 /OUT pdfmark
        [ /Title (6.8.3 Reading numbers) /Page 246 /OUT pdfmark

      [ /Title (6.9 Program structure) /Page 247 /OUT pdfmark

    [ /Count -8 /Title (Chapter 7 Completing a Program) /Page 253 /OUT pdfmark
      [ /Title (7.1 Introduction) /Page 254 /OUT pdfmark
      [ /Title (7.2 Input and output) /Page 254 /OUT pdfmark
      [ /Title (7.3 Error handling) /Page 256 /OUT pdfmark
      [ /Title (7.4 Negative numbers) /Page 261 /OUT pdfmark
      [ /Title (7.5 Remainder: %) /Page 262 /OUT pdfmark
      [ /Count -4 /Title (7.6 Cleaning up the code) /Page 264 /OUT pdfmark
        [ /Title (7.6.1 Symbolic constants) /Page 264 /OUT pdfmark
        [ /Title (7.6.2 Use of functions) /Page 266 /OUT pdfmark
        [ /Title (7.6.3 Code layout) /Page 267 /OUT pdfmark
        [ /Title (7.6.4 Commenting) /Page 269 /OUT pdfmark

      [ /Title (7.7 Recovering from errors) /Page 271 /OUT pdfmark
      [ /Count -4 /Title (7.8 Variables) /Page 274 /OUT pdfmark
        [ /Title (7.8.1 Variables and definitions) /Page 274 /OUT pdfmark
        [ /Title (7.8.2 Introducing names) /Page 279 /OUT pdfmark
        [ /Title (7.8.3 Predefined names) /Page 282 /OUT pdfmark
        [ /Title (7.8.4 Are we there yet?) /Page 282 /OUT pdfmark


    [ /Count -7 /Title (Chapter 8 Technicalities: Functions, etc.) /Page 287 /OUT pdfmark
      [ /Title (8.1 Technicalities) /Page 288 /OUT pdfmark
      [ /Count -3 /Title (8.2 Declarations and definitions) /Page 289 /OUT pdfmark
        [ /Title (8.2.1 Kinds of declarations) /Page 293 /OUT pdfmark
        [ /Title (8.2.2 Variable and constant declarations) /Page 294 /OUT pdfmark
        [ /Title (8.2.3 Default initialization) /Page 295 /OUT pdfmark

      [ /Title (8.3 Header files) /Page 296 /OUT pdfmark
      [ /Title (8.4 Scope) /Page 298 /OUT pdfmark
      [ /Count -9 /Title (8.5 Function call and return) /Page 304 /OUT pdfmark
        [ /Title (8.5.1 Declaring arguments and return type) /Page 304 /OUT pdfmark
        [ /Title (8.5.2 Returning a value) /Page 306 /OUT pdfmark
        [ /Title (8.5.3 Pass-by-value) /Page 307 /OUT pdfmark
        [ /Title (8.5.4 Pass-by-const-reference) /Page 308 /OUT pdfmark
        [ /Title (8.5.5 Pass-by-reference) /Page 311 /OUT pdfmark
        [ /Title (8.5.6 Pass-by-value vs. pass-by-reference) /Page 313 /OUT pdfmark
        [ /Title (8.5.7 Argument checking and conversion) /Page 316 /OUT pdfmark
        [ /Title (8.5.8 Function call implementation) /Page 317 /OUT pdfmark
        [ /Title (8.5.9 constexpr functions) /Page 322 /OUT pdfmark

      [ /Count -2 /Title (8.6 Order of evaluation) /Page 323 /OUT pdfmark
        [ /Title (8.6.1 Expression evaluation) /Page 324 /OUT pdfmark
        [ /Title (8.6.2 Global initialization) /Page 325 /OUT pdfmark

      [ /Count -1 /Title (8.7 Namespaces) /Page 326 /OUT pdfmark
        [ /Title (8.7.1 using declarations and using directives) /Page 328 /OUT pdfmark


    [ /Count -8 /Title (Chapter 9 Technicalities: Classes, etc.) /Page 335 /OUT pdfmark
      [ /Title (9.1 User-defined types) /Page 336 /OUT pdfmark
      [ /Title (9.2 Classes and members) /Page 337 /OUT pdfmark
      [ /Title (9.3 Interface and implementation) /Page 338 /OUT pdfmark
      [ /Count -6 /Title (9.4 Evolving a class) /Page 340 /OUT pdfmark
        [ /Title (9.4.1 struct and functions) /Page 340 /OUT pdfmark
        [ /Title (9.4.2 Member functions and constructors) /Page 342 /OUT pdfmark
        [ /Title (9.4.3 Keep details private) /Page 344 /OUT pdfmark
        [ /Title (9.4.4 Defining member functions) /Page 346 /OUT pdfmark
        [ /Title (9.4.5 Referring to the current object) /Page 349 /OUT pdfmark
        [ /Title (9.4.6 Reporting errors) /Page 349 /OUT pdfmark

      [ /Count -1 /Title (9.5 Enumerations) /Page 350 /OUT pdfmark
        [ /Title (9.5.1 “Plain” enumerations) /Page 352 /OUT pdfmark

      [ /Title (9.6 Operator overloading) /Page 353 /OUT pdfmark
      [ /Count -5 /Title (9.7 Class interfaces) /Page 355 /OUT pdfmark
        [ /Title (9.7.1 Argument types) /Page 356 /OUT pdfmark
        [ /Title (9.7.2 Copying) /Page 358 /OUT pdfmark
        [ /Title (9.7.3 Default constructors) /Page 359 /OUT pdfmark
        [ /Title (9.7.4 const member functions) /Page 362 /OUT pdfmark
        [ /Title (9.7.5 Members and “helper functions”) /Page 364 /OUT pdfmark

      [ /Title (9.8 The Date class) /Page 366 /OUT pdfmark


  [ /Count -7 /Title (Part II Input and Output) /Page 375 /OUT pdfmark
    [ /Count -11 /Title (Chapter 10 Input and Output Streams) /Page 377 /OUT pdfmark
      [ /Title (10.1 Input and output) /Page 378 /OUT pdfmark
      [ /Title (10.2 The I/O stream model) /Page 379 /OUT pdfmark
      [ /Title (10.3 Files) /Page 381 /OUT pdfmark
      [ /Title (10.4 Opening a file) /Page 382 /OUT pdfmark
      [ /Title (10.5 Reading and writing a file) /Page 384 /OUT pdfmark
      [ /Title (10.6 I/O error handling) /Page 386 /OUT pdfmark
      [ /Count -2 /Title (10.7 Reading a single value) /Page 390 /OUT pdfmark
        [ /Title (10.7.1 Breaking the problem into manageable parts) /Page 391 /OUT pdfmark
        [ /Title (10.7.2 Separating dialog from function) /Page 394 /OUT pdfmark

      [ /Title (10.8 User-defined output operators) /Page 395 /OUT pdfmark
      [ /Title (10.9 User-defined input operators) /Page 397 /OUT pdfmark
      [ /Title (10.10 A standard input loop) /Page 397 /OUT pdfmark
      [ /Count -3 /Title (10.11 Reading a structured file) /Page 399 /OUT pdfmark
        [ /Title (10.11.1 In-memory representation) /Page 400 /OUT pdfmark
        [ /Title (10.11.2 Reading structured values) /Page 402 /OUT pdfmark
        [ /Title (10.11.3 Changing representations) /Page 406 /OUT pdfmark


    [ /Count -8 /Title (Chapter 11 Customizing Input and Output) /Page 411 /OUT pdfmark
      [ /Title (11.1 Regularity and irregularity) /Page 412 /OUT pdfmark
      [ /Count -5 /Title (11.2 Output formatting) /Page 412 /OUT pdfmark
        [ /Title (11.2.1 Integer output) /Page 413 /OUT pdfmark
        [ /Title (11.2.2 Integer input) /Page 415 /OUT pdfmark
        [ /Title (11.2.3 Floating-point output) /Page 416 /OUT pdfmark
        [ /Title (11.2.4 Precision) /Page 417 /OUT pdfmark
        [ /Title (11.2.5 Fields) /Page 419 /OUT pdfmark

      [ /Count -3 /Title (11.3 File opening and positioning) /Page 420 /OUT pdfmark
        [ /Title (11.3.1 File open modes) /Page 420 /OUT pdfmark
        [ /Title (11.3.2 Binary files) /Page 422 /OUT pdfmark
        [ /Title (11.3.3 Positioning in files) /Page 425 /OUT pdfmark

      [ /Title (11.4 String streams) /Page 426 /OUT pdfmark
      [ /Title (11.5 Line-oriented input) /Page 427 /OUT pdfmark
      [ /Title (11.6 Character classification) /Page 428 /OUT pdfmark
      [ /Title (11.7 Using nonstandard separators) /Page 430 /OUT pdfmark
      [ /Title (11.8 And there is so much more) /Page 438 /OUT pdfmark

    [ /Count -8 /Title (Chapter 12 A Display Model) /Page 443 /OUT pdfmark
      [ /Title (12.1 Why graphics?) /Page 444 /OUT pdfmark
      [ /Title (12.2 A display model) /Page 445 /OUT pdfmark
      [ /Title (12.3 A first example) /Page 446 /OUT pdfmark
      [ /Title (12.4 Using a GUI library) /Page 450 /OUT pdfmark
      [ /Title (12.5 Coordinates) /Page 451 /OUT pdfmark
      [ /Title (12.6 Shapes) /Page 452 /OUT pdfmark
      [ /Count -10 /Title (12.7 Using Shape primitives) /Page 453 /OUT pdfmark
        [ /Title (12.7.1 Graphics headers and main) /Page 453 /OUT pdfmark
        [ /Title (12.7.2 An almost blank window) /Page 454 /OUT pdfmark
        [ /Title (12.7.3 Axis) /Page 456 /OUT pdfmark
        [ /Title (12.7.4 Graphing a function) /Page 458 /OUT pdfmark
        [ /Title (12.7.5 Polygons) /Page 459 /OUT pdfmark
        [ /Title (12.7.6 Rectangles) /Page 460 /OUT pdfmark
        [ /Title (12.7.7 Fill) /Page 463 /OUT pdfmark
        [ /Title (12.7.8 Text) /Page 463 /OUT pdfmark
        [ /Title (12.7.9 Images) /Page 465 /OUT pdfmark
        [ /Title (12.7.10 And much more) /Page 466 /OUT pdfmark

      [ /Count -1 /Title (12.8 Getting this to run) /Page 467 /OUT pdfmark
        [ /Title (12.8.1 Source files) /Page 469 /OUT pdfmark


    [ /Count -17 /Title (Chapter 13 Graphics Classes) /Page 473 /OUT pdfmark
      [ /Title (13.1 Overview of graphics classes) /Page 474 /OUT pdfmark
      [ /Title (13.2 Point and Line) /Page 476 /OUT pdfmark
      [ /Title (13.3 Lines) /Page 479 /OUT pdfmark
      [ /Title (13.4 Color) /Page 482 /OUT pdfmark
      [ /Title (13.5 Line_style) /Page 484 /OUT pdfmark
      [ /Title (13.6 Open_polyline) /Page 487 /OUT pdfmark
      [ /Title (13.7 Closed_polyline) /Page 488 /OUT pdfmark
      [ /Title (13.8 Polygon) /Page 490 /OUT pdfmark
      [ /Title (13.9 Rectangle) /Page 492 /OUT pdfmark
      [ /Title (13.10 Managing unnamed objects) /Page 497 /OUT pdfmark
      [ /Title (13.11 Text) /Page 499 /OUT pdfmark
      [ /Title (13.12 Circle) /Page 502 /OUT pdfmark
      [ /Title (13.13 Ellipse) /Page 504 /OUT pdfmark
      [ /Title (13.14 Marked_polyline) /Page 506 /OUT pdfmark
      [ /Title (13.15 Marks) /Page 508 /OUT pdfmark
      [ /Title (13.16 Mark) /Page 510 /OUT pdfmark
      [ /Title (13.17 Images) /Page 511 /OUT pdfmark

    [ /Count -4 /Title (Chapter 14 Graphics Class Design) /Page 519 /OUT pdfmark
      [ /Count -4 /Title (14.1 Design principles) /Page 520 /OUT pdfmark
        [ /Title (14.1.1 Types) /Page 520 /OUT pdfmark
        [ /Title (14.1.2 Operations) /Page 522 /OUT pdfmark
        [ /Title (14.1.3 Naming) /Page 523 /OUT pdfmark
        [ /Title (14.1.4 Mutability) /Page 524 /OUT pdfmark

      [ /Count -4 /Title (14.2 Shape) /Page 525 /OUT pdfmark
        [ /Title (14.2.1 An abstract class) /Page 527 /OUT pdfmark
        [ /Title (14.2.2 Access control) /Page 528 /OUT pdfmark
        [ /Title (14.2.3 Drawing shapes) /Page 532 /OUT pdfmark
        [ /Title (14.2.4 Copying and mutability) /Page 535 /OUT pdfmark

      [ /Count -5 /Title (14.3 Base and derived classes) /Page 536 /OUT pdfmark
        [ /Title (14.3.1 Object layout) /Page 538 /OUT pdfmark
        [ /Title (14.3.2 Deriving classes and defining virtual functions) /Page 539 /OUT pdfmark
        [ /Title (14.3.3 Overriding) /Page 540 /OUT pdfmark
        [ /Title (14.3.4 Access) /Page 543 /OUT pdfmark
        [ /Title (14.3.5 Pure virtual functions) /Page 544 /OUT pdfmark

      [ /Title (14.4 Benefits of object-oriented programming) /Page 545 /OUT pdfmark

    [ /Count -6 /Title (Chapter 15 Graphing Functions and Data) /Page 551 /OUT pdfmark
      [ /Title (15.1 Introduction) /Page 552 /OUT pdfmark
      [ /Title (15.2 Graphing simple functions) /Page 552 /OUT pdfmark
      [ /Count -3 /Title (15.3 Function) /Page 556 /OUT pdfmark
        [ /Title (15.3.1 Default Arguments) /Page 557 /OUT pdfmark
        [ /Title (15.3.2 More examples) /Page 559 /OUT pdfmark
        [ /Title (15.3.3 Lambda expressions) /Page 560 /OUT pdfmark

      [ /Title (15.4 Axis) /Page 561 /OUT pdfmark
      [ /Title (15.5 Approximation) /Page 564 /OUT pdfmark
      [ /Count -4 /Title (15.6 Graphing data) /Page 569 /OUT pdfmark
        [ /Title (15.6.1 Reading a file) /Page 571 /OUT pdfmark
        [ /Title (15.6.2 General layout) /Page 573 /OUT pdfmark
        [ /Title (15.6.3 Scaling data) /Page 574 /OUT pdfmark
        [ /Title (15.6.4 Building the graph) /Page 575 /OUT pdfmark


    [ /Count -8 /Title (Chapter 16 Graphical User Interfaces) /Page 583 /OUT pdfmark
      [ /Title (16.1 User interface alternatives) /Page 584 /OUT pdfmark
      [ /Title (16.2 The “Next” button) /Page 585 /OUT pdfmark
      [ /Count -3 /Title (16.3 A simple window) /Page 586 /OUT pdfmark
        [ /Title (16.3.1 A callback function) /Page 588 /OUT pdfmark
        [ /Title (16.3.2 A wait loop) /Page 591 /OUT pdfmark
        [ /Title (16.3.3 A lambda expression as a callback) /Page 592 /OUT pdfmark

      [ /Count -4 /Title (16.4 Button and other Widgets) /Page 593 /OUT pdfmark
        [ /Title (16.4.1 Widgets) /Page 593 /OUT pdfmark
        [ /Title (16.4.2 Buttons) /Page 595 /OUT pdfmark
        [ /Title (16.4.3 In_box and Out_box) /Page 595 /OUT pdfmark
        [ /Title (16.4.4 Menus) /Page 596 /OUT pdfmark

      [ /Title (16.5 An example) /Page 597 /OUT pdfmark
      [ /Title (16.6 Control inversion) /Page 601 /OUT pdfmark
      [ /Title (16.7 Adding a menu) /Page 602 /OUT pdfmark
      [ /Title (16.8 Debugging GUI code) /Page 607 /OUT pdfmark


  [ /Count -5 /Title (Part III Data and Algorithms) /Page 613 /OUT pdfmark
    [ /Count -10 /Title (Chapter 17 Vector and Free Store) /Page 615 /OUT pdfmark
      [ /Title (17.1 Introduction) /Page 616 /OUT pdfmark
      [ /Title (17.2 vector basics) /Page 618 /OUT pdfmark
      [ /Count -1 /Title (17.3 Memory, addresses, and pointers) /Page 620 /OUT pdfmark
        [ /Title (17.3.1 The sizeof operator) /Page 622 /OUT pdfmark

      [ /Count -6 /Title (17.4 Free store and pointers) /Page 623 /OUT pdfmark
        [ /Title (17.4.1 Free-store allocation) /Page 625 /OUT pdfmark
        [ /Title (17.4.2 Access through pointers) /Page 626 /OUT pdfmark
        [ /Title (17.4.3 Ranges) /Page 627 /OUT pdfmark
        [ /Title (17.4.4 Initialization) /Page 628 /OUT pdfmark
        [ /Title (17.4.5 The null pointer) /Page 630 /OUT pdfmark
        [ /Title (17.4.6 Free-store deallocation) /Page 630 /OUT pdfmark

      [ /Count -2 /Title (17.5 Destructors) /Page 633 /OUT pdfmark
        [ /Title (17.5.1 Generated destructors) /Page 635 /OUT pdfmark
        [ /Title (17.5.2 Destructors and free store) /Page 636 /OUT pdfmark

      [ /Title (17.6 Access to elements) /Page 637 /OUT pdfmark
      [ /Title (17.7 Pointers to class objects) /Page 638 /OUT pdfmark
      [ /Title (17.8 Messing with types: void* and casts) /Page 640 /OUT pdfmark
      [ /Count -5 /Title (17.9 Pointers and references) /Page 642 /OUT pdfmark
        [ /Title (17.9.1 Pointer and reference parameters) /Page 643 /OUT pdfmark
        [ /Title (17.9.2 Pointers, references, and inheritance) /Page 644 /OUT pdfmark
        [ /Title (17.9.3 An example: lists) /Page 645 /OUT pdfmark
        [ /Title (17.9.4 List operations) /Page 647 /OUT pdfmark
        [ /Title (17.9.5 List use) /Page 648 /OUT pdfmark

      [ /Count -1 /Title (17.10 The this pointer) /Page 650 /OUT pdfmark
        [ /Title (17.10.1 More link use) /Page 652 /OUT pdfmark


    [ /Count -7 /Title (Chapter 18 Vectors and Arrays) /Page 659 /OUT pdfmark
      [ /Title (18.1 Introduction) /Page 660 /OUT pdfmark
      [ /Title (18.2 Initialization) /Page 661 /OUT pdfmark
      [ /Count -4 /Title (18.3 Copying) /Page 663 /OUT pdfmark
        [ /Title (18.3.1 Copy constructors) /Page 665 /OUT pdfmark
        [ /Title (18.3.2 Copy assignments) /Page 666 /OUT pdfmark
        [ /Title (18.3.3 Copy terminology) /Page 668 /OUT pdfmark
        [ /Title (18.3.4 Moving) /Page 669 /OUT pdfmark

      [ /Count -2 /Title (18.4 Essential operations) /Page 672 /OUT pdfmark
        [ /Title (18.4.1 Explicit constructors) /Page 674 /OUT pdfmark
        [ /Title (18.4.2 Debugging constructors and destructors) /Page 675 /OUT pdfmark

      [ /Count -1 /Title (18.5 Access to vector elements) /Page 678 /OUT pdfmark
        [ /Title (18.5.1 Overloading on const) /Page 679 /OUT pdfmark

      [ /Count -4 /Title (18.6 Arrays) /Page 680 /OUT pdfmark
        [ /Title (18.6.1 Pointers to array elements) /Page 682 /OUT pdfmark
        [ /Title (18.6.2 Pointers and arrays) /Page 684 /OUT pdfmark
        [ /Title (18.6.3 Array initialization) /Page 686 /OUT pdfmark
        [ /Title (18.6.4 Pointer problems) /Page 688 /OUT pdfmark

      [ /Count -3 /Title (18.7 Examples: palindrome) /Page 691 /OUT pdfmark
        [ /Title (18.7.1 Palindromes using string) /Page 691 /OUT pdfmark
        [ /Title (18.7.2 Palindromes using arrays) /Page 692 /OUT pdfmark
        [ /Title (18.7.3 Palindromes using pointers) /Page 693 /OUT pdfmark


    [ /Count -5 /Title (Chapter 19 Vector, Templates, and Exceptions) /Page 699 /OUT pdfmark
      [ /Title (19.1 The problems) /Page 700 /OUT pdfmark
      [ /Count -6 /Title (19.2 Changing size) /Page 703 /OUT pdfmark
        [ /Title (19.2.1 Representation) /Page 703 /OUT pdfmark
        [ /Title (19.2.2 reserve and capacity) /Page 705 /OUT pdfmark
        [ /Title (19.2.3 resize) /Page 706 /OUT pdfmark
        [ /Title (19.2.4 push_back) /Page 706 /OUT pdfmark
        [ /Title (19.2.5 Assignment) /Page 707 /OUT pdfmark
        [ /Title (19.2.6 Our vector so far) /Page 709 /OUT pdfmark

      [ /Count -7 /Title (19.3 Templates) /Page 710 /OUT pdfmark
        [ /Title (19.3.1 Types as template parameters) /Page 711 /OUT pdfmark
        [ /Title (19.3.2 Generic programming) /Page 713 /OUT pdfmark
        [ /Title (19.3.3 Concepts) /Page 715 /OUT pdfmark
        [ /Title (19.3.4 Containers and inheritance) /Page 718 /OUT pdfmark
        [ /Title (19.3.5 Integers as template parameters) /Page 719 /OUT pdfmark
        [ /Title (19.3.6 Template argument deduction) /Page 721 /OUT pdfmark
        [ /Title (19.3.7 Generalizing vector) /Page 722 /OUT pdfmark

      [ /Count -2 /Title (19.4 Range checking and exceptions) /Page 725 /OUT pdfmark
        [ /Title (19.4.1 An aside: design considerations) /Page 726 /OUT pdfmark
        [ /Title (19.4.2 A confession: macros) /Page 728 /OUT pdfmark

      [ /Count -6 /Title (19.5 Resources and exceptions) /Page 729 /OUT pdfmark
        [ /Title (19.5.1 Potential resource management problems) /Page 730 /OUT pdfmark
        [ /Title (19.5.2 Resource acquisition is initialization) /Page 732 /OUT pdfmark
        [ /Title (19.5.3 Guarantees) /Page 733 /OUT pdfmark
        [ /Title (19.5.4 unique_ptr) /Page 735 /OUT pdfmark
        [ /Title (19.5.5 Return by moving) /Page 736 /OUT pdfmark
        [ /Title (19.5.6 RAII for vector) /Page 737 /OUT pdfmark


    [ /Count -10 /Title (Chapter 20 Containers and Iterators) /Page 743 /OUT pdfmark
      [ /Count -2 /Title (20.1 Storing and processing data) /Page 744 /OUT pdfmark
        [ /Title (20.1.1 Working with data) /Page 745 /OUT pdfmark
        [ /Title (20.1.2 Generalizing code) /Page 746 /OUT pdfmark

      [ /Title (20.2 STL ideals) /Page 749 /OUT pdfmark
      [ /Count -1 /Title (20.3 Sequences and iterators) /Page 752 /OUT pdfmark
        [ /Title (20.3.1 Back to the example) /Page 755 /OUT pdfmark

      [ /Count -2 /Title (20.4 Linked lists) /Page 756 /OUT pdfmark
        [ /Title (20.4.1 List operations) /Page 758 /OUT pdfmark
        [ /Title (20.4.2 Iteration) /Page 759 /OUT pdfmark

      [ /Count -2 /Title (20.5 Generalizing vector yet again) /Page 761 /OUT pdfmark
        [ /Title (20.5.1 Container traversal) /Page 764 /OUT pdfmark
        [ /Title (20.5.2 auto) /Page 764 /OUT pdfmark

      [ /Count -2 /Title (20.6 An example: a simple text editor) /Page 766 /OUT pdfmark
        [ /Title (20.6.1 Lines) /Page 768 /OUT pdfmark
        [ /Title (20.6.2 Iteration) /Page 769 /OUT pdfmark

      [ /Count -1 /Title (20.7 vector, list, and string) /Page 773 /OUT pdfmark
        [ /Title (20.7.1 insert and erase) /Page 774 /OUT pdfmark

      [ /Title (20.8 Adapting our vector to the STL) /Page 777 /OUT pdfmark
      [ /Title (20.9 Adapting built-in arrays to the STL) /Page 779 /OUT pdfmark
      [ /Count -1 /Title (20.10 Container overview) /Page 781 /OUT pdfmark
        [ /Title (20.10.1 Iterator categories) /Page 783 /OUT pdfmark


    [ /Count -9 /Title (Chapter 21 Algorithms and Maps) /Page 789 /OUT pdfmark
      [ /Title (21.1 Standard library algorithms) /Page 790 /OUT pdfmark
      [ /Count -1 /Title (21.2 The simplest algorithm: find()) /Page 791 /OUT pdfmark
        [ /Title (21.2.1 Some generic uses) /Page 793 /OUT pdfmark

      [ /Title (21.3 The general search: find_if()) /Page 795 /OUT pdfmark
      [ /Count -3 /Title (21.4 Function objects) /Page 797 /OUT pdfmark
        [ /Title (21.4.1 An abstract view of function objects) /Page 798 /OUT pdfmark
        [ /Title (21.4.2 Predicates on class members) /Page 799 /OUT pdfmark
        [ /Title (21.4.3 Lambda expressions) /Page 801 /OUT pdfmark

      [ /Count -4 /Title (21.5 Numerical algorithms) /Page 802 /OUT pdfmark
        [ /Title (21.5.1 Accumulate) /Page 802 /OUT pdfmark
        [ /Title (21.5.2 Generalizing accumulate()) /Page 804 /OUT pdfmark
        [ /Title (21.5.3 Inner product) /Page 806 /OUT pdfmark
        [ /Title (21.5.4 Generalizing inner_product()) /Page 807 /OUT pdfmark

      [ /Count -5 /Title (21.6 Associative containers) /Page 808 /OUT pdfmark
        [ /Title (21.6.1 map) /Page 808 /OUT pdfmark
        [ /Title (21.6.2 map overview) /Page 811 /OUT pdfmark
        [ /Title (21.6.3 Another map example) /Page 814 /OUT pdfmark
        [ /Title (21.6.4 unordered_map) /Page 817 /OUT pdfmark
        [ /Title (21.6.5 set) /Page 819 /OUT pdfmark

      [ /Count -4 /Title (21.7 Copying) /Page 821 /OUT pdfmark
        [ /Title (21.7.1 Copy) /Page 821 /OUT pdfmark
        [ /Title (21.7.2 Stream iterators) /Page 822 /OUT pdfmark
        [ /Title (21.7.3 Using a set to keep order) /Page 825 /OUT pdfmark
        [ /Title (21.7.4 copy_if) /Page 826 /OUT pdfmark

      [ /Title (21.8 Sorting and searching) /Page 826 /OUT pdfmark
      [ /Title (21.9 Container algorithms) /Page 829 /OUT pdfmark


  [ /Count -6 /Title (Part IV Broadening the View) /Page 835 /OUT pdfmark
    [ /Count -2 /Title (Chapter 22 Ideals and History) /Page 837 /OUT pdfmark
      [ /Count -3 /Title (22.1 History, ideals, and professionalism) /Page 838 /OUT pdfmark
        [ /Title (22.1.1 Programming language aims and philosophies) /Page 839 /OUT pdfmark
        [ /Title (22.1.2 Programming ideals) /Page 840 /OUT pdfmark
        [ /Title (22.1.3 Styles/paradigms) /Page 847 /OUT pdfmark

      [ /Count -8 /Title (22.2 Programming language history overview) /Page 850 /OUT pdfmark
        [ /Title (22.2.1 The earliest languages) /Page 851 /OUT pdfmark
        [ /Title (22.2.2 The roots of modern languages) /Page 853 /OUT pdfmark
        [ /Title (22.2.3 The Algol family) /Page 858 /OUT pdfmark
        [ /Title (22.2.4 Simula) /Page 865 /OUT pdfmark
        [ /Title (22.2.5 C) /Page 868 /OUT pdfmark
        [ /Title (22.2.6 C++) /Page 871 /OUT pdfmark
        [ /Title (22.2.7 Today) /Page 874 /OUT pdfmark
        [ /Title (22.2.8 Information sources) /Page 876 /OUT pdfmark


    [ /Count -10 /Title (Chapter 23 Text Manipulation) /Page 881 /OUT pdfmark
      [ /Title (23.1 Text) /Page 882 /OUT pdfmark
      [ /Title (23.2 Strings) /Page 882 /OUT pdfmark
      [ /Title (23.3 I/O streams) /Page 887 /OUT pdfmark
      [ /Count -1 /Title (23.4 Maps) /Page 887 /OUT pdfmark
        [ /Title (23.4.1 Implementation details) /Page 893 /OUT pdfmark

      [ /Title (23.5 A problem) /Page 896 /OUT pdfmark
      [ /Count -1 /Title (23.6 The idea of regular expressions) /Page 898 /OUT pdfmark
        [ /Title (23.6.1 Raw string literals) /Page 900 /OUT pdfmark

      [ /Title (23.7 Searching with regular expressions) /Page 901 /OUT pdfmark
      [ /Count -7 /Title (23.8 Regular expression syntax) /Page 904 /OUT pdfmark
        [ /Title (23.8.1 Characters and special characters) /Page 904 /OUT pdfmark
        [ /Title (23.8.2 Character classes) /Page 905 /OUT pdfmark
        [ /Title (23.8.3 Repeats) /Page 906 /OUT pdfmark
        [ /Title (23.8.4 Grouping) /Page 908 /OUT pdfmark
        [ /Title (23.8.5 Alternation) /Page 908 /OUT pdfmark
        [ /Title (23.8.6 Character sets and ranges) /Page 909 /OUT pdfmark
        [ /Title (23.8.7 Regular expression errors) /Page 910 /OUT pdfmark

      [ /Title (23.9 Matching with regular expressions) /Page 912 /OUT pdfmark
      [ /Title (23.10 References) /Page 917 /OUT pdfmark

    [ /Count -10 /Title (Chapter 24 Numerics) /Page 921 /OUT pdfmark
      [ /Title (24.1 Introduction) /Page 922 /OUT pdfmark
      [ /Count -1 /Title (24.2 Size, precision, and overflow) /Page 922 /OUT pdfmark
        [ /Title (24.2.1 Numeric limits) /Page 926 /OUT pdfmark

      [ /Title (24.3 Arrays) /Page 927 /OUT pdfmark
      [ /Title (24.4 C-style multidimensional arrays) /Page 928 /OUT pdfmark
      [ /Count -5 /Title (24.5 The Matrix library) /Page 929 /OUT pdfmark
        [ /Title (24.5.1 Dimensions and access) /Page 930 /OUT pdfmark
        [ /Title (24.5.2 1D Matrix) /Page 933 /OUT pdfmark
        [ /Title (24.5.3 2D Matrix) /Page 936 /OUT pdfmark
        [ /Title (24.5.4 Matrix I/O) /Page 939 /OUT pdfmark
        [ /Title (24.5.5 3D Matrix) /Page 939 /OUT pdfmark

      [ /Count -3 /Title (24.6 An example: solving linear equations) /Page 940 /OUT pdfmark
        [ /Title (24.6.1 Classical Gaussian elimination) /Page 942 /OUT pdfmark
        [ /Title (24.6.2 Pivoting) /Page 943 /OUT pdfmark
        [ /Title (24.6.3 Testing) /Page 944 /OUT pdfmark

      [ /Title (24.7 Random numbers) /Page 946 /OUT pdfmark
      [ /Title (24.8 The standard mathematical functions) /Page 949 /OUT pdfmark
      [ /Title (24.9 Complex numbers) /Page 951 /OUT pdfmark
      [ /Title (24.10 References) /Page 952 /OUT pdfmark

    [ /Count -6 /Title (Chapter 25 Embedded Systems Programming) /Page 957 /OUT pdfmark
      [ /Title (25.1 Embedded systems) /Page 958 /OUT pdfmark
      [ /Count -3 /Title (25.2 Basic concepts) /Page 961 /OUT pdfmark
        [ /Title (25.2.1 Predictability) /Page 964 /OUT pdfmark
        [ /Title (25.2.2 Ideals) /Page 964 /OUT pdfmark
        [ /Title (25.2.3 Living with failure) /Page 965 /OUT pdfmark

      [ /Count -4 /Title (25.3 Memory management) /Page 967 /OUT pdfmark
        [ /Title (25.3.1 Free-store problems) /Page 968 /OUT pdfmark
        [ /Title (25.3.2 Alternatives to the general free store) /Page 971 /OUT pdfmark
        [ /Title (25.3.3 Pool example) /Page 972 /OUT pdfmark
        [ /Title (25.3.4 Stack example) /Page 974 /OUT pdfmark

      [ /Count -4 /Title (25.4 Addresses, pointers, and arrays) /Page 975 /OUT pdfmark
        [ /Title (25.4.1 Unchecked conversions) /Page 975 /OUT pdfmark
        [ /Title (25.4.2 A problem: dysfunctional interfaces) /Page 976 /OUT pdfmark
        [ /Title (25.4.3 A solution: an interface class) /Page 979 /OUT pdfmark
        [ /Title (25.4.4 Inheritance and containers) /Page 983 /OUT pdfmark

      [ /Count -6 /Title (25.5 Bits, bytes, and words) /Page 986 /OUT pdfmark
        [ /Title (25.5.1 Bits and bit operations) /Page 987 /OUT pdfmark
        [ /Title (25.5.2 bitset) /Page 991 /OUT pdfmark
        [ /Title (25.5.3 Signed and unsigned) /Page 993 /OUT pdfmark
        [ /Title (25.5.4 Bit manipulation) /Page 997 /OUT pdfmark
        [ /Title (25.5.5 Bitfields) /Page 999 /OUT pdfmark
        [ /Title (25.5.6 An example: simple encryption) /Page 1001 /OUT pdfmark

      [ /Count -3 /Title (25.6 Coding standards) /Page 1006 /OUT pdfmark
        [ /Title (25.6.1 What should a coding standard be?) /Page 1007 /OUT pdfmark
        [ /Title (25.6.2 Sample rules) /Page 1009 /OUT pdfmark
        [ /Title (25.6.3 Real coding standards) /Page 1015 /OUT pdfmark


    [ /Count -7 /Title (Chapter 26 Testing) /Page 1021 /OUT pdfmark
      [ /Count -1 /Title (26.1 What we want) /Page 1022 /OUT pdfmark
        [ /Title (26.1.1 Caveat) /Page 1023 /OUT pdfmark

      [ /Title (26.2 Proofs) /Page 1024 /OUT pdfmark
      [ /Count -5 /Title (26.3 Testing) /Page 1024 /OUT pdfmark
        [ /Title (26.3.1 Regression tests) /Page 1025 /OUT pdfmark
        [ /Title (26.3.2 Unit tests) /Page 1026 /OUT pdfmark
        [ /Title (26.3.3 Algorithms and non-algorithms) /Page 1033 /OUT pdfmark
        [ /Title (26.3.4 System tests) /Page 1041 /OUT pdfmark
        [ /Title (26.3.5 Finding assumptions that do not hold) /Page 1041 /OUT pdfmark

      [ /Title (26.4 Design for testing) /Page 1043 /OUT pdfmark
      [ /Title (26.5 Debugging) /Page 1044 /OUT pdfmark
      [ /Count -1 /Title (26.6 Performance) /Page 1044 /OUT pdfmark
        [ /Title (26.6.1 Timing) /Page 1047 /OUT pdfmark

      [ /Title (26.7 References) /Page 1048 /OUT pdfmark

    [ /Count -9 /Title (Chapter 27 The C Programming Language) /Page 1053 /OUT pdfmark
      [ /Count -3 /Title (27.1 C and C++: siblings) /Page 1054 /OUT pdfmark
        [ /Title (27.1.1 C/C++ compatibility) /Page 1056 /OUT pdfmark
        [ /Title (27.1.2 C++ features missing from C) /Page 1057 /OUT pdfmark
        [ /Title (27.1.3 The C standard library) /Page 1059 /OUT pdfmark

      [ /Count -5 /Title (27.2 Functions) /Page 1060 /OUT pdfmark
        [ /Title (27.2.1 No function name overloading) /Page 1060 /OUT pdfmark
        [ /Title (27.2.2 Function argument type checking) /Page 1061 /OUT pdfmark
        [ /Title (27.2.3 Function definitions) /Page 1063 /OUT pdfmark
        [ /Title (27.2.4 Calling C from C++ and C++ from C) /Page 1064 /OUT pdfmark
        [ /Title (27.2.5 Pointers to functions) /Page 1066 /OUT pdfmark

      [ /Count -7 /Title (27.3 Minor language differences) /Page 1068 /OUT pdfmark
        [ /Title (27.3.1 struct tag namespace) /Page 1068 /OUT pdfmark
        [ /Title (27.3.2 Keywords) /Page 1069 /OUT pdfmark
        [ /Title (27.3.3 Definitions) /Page 1070 /OUT pdfmark
        [ /Title (27.3.4 C-style casts) /Page 1072 /OUT pdfmark
        [ /Title (27.3.5 Conversion of void*) /Page 1073 /OUT pdfmark
        [ /Title (27.3.6 enum) /Page 1074 /OUT pdfmark
        [ /Title (27.3.7 Namespaces) /Page 1074 /OUT pdfmark

      [ /Title (27.4 Free store) /Page 1075 /OUT pdfmark
      [ /Count -4 /Title (27.5 C-style strings) /Page 1077 /OUT pdfmark
        [ /Title (27.5.1 C-style strings and const) /Page 1079 /OUT pdfmark
        [ /Title (27.5.2 Byte operations) /Page 1080 /OUT pdfmark
        [ /Title (27.5.3 An example: strcpy()) /Page 1081 /OUT pdfmark
        [ /Title (27.5.4 A style issue) /Page 1081 /OUT pdfmark

      [ /Count -3 /Title (27.6 Input/output: stdio) /Page 1082 /OUT pdfmark
        [ /Title (27.6.1 Output) /Page 1082 /OUT pdfmark
        [ /Title (27.6.2 Input) /Page 1084 /OUT pdfmark
        [ /Title (27.6.3 Files) /Page 1085 /OUT pdfmark

      [ /Title (27.7 Constants and macros) /Page 1086 /OUT pdfmark
      [ /Count -3 /Title (27.8 Macros) /Page 1087 /OUT pdfmark
        [ /Title (27.8.1 Function-like macros) /Page 1088 /OUT pdfmark
        [ /Title (27.8.2 Syntax macros) /Page 1090 /OUT pdfmark
        [ /Title (27.8.3 Conditional compilation) /Page 1090 /OUT pdfmark

      [ /Title (27.9 An example: intrusive containers) /Page 1091 /OUT pdfmark


  [ /Count -5 /Title (Part V Appendices) /Page 1103 /OUT pdfmark
    [ /Count -17 /Title (Appendix A Language Summary) /Page 1105 /OUT pdfmark
      [ /Count -3 /Title (A.1 General) /Page 1106 /OUT pdfmark
        [ /Title (A.1.1 Terminology) /Page 1107 /OUT pdfmark
        [ /Title (A.1.2 Program start and termination) /Page 1107 /OUT pdfmark
        [ /Title (A.1.3 Comments) /Page 1108 /OUT pdfmark

      [ /Count -6 /Title (A.2 Literals) /Page 1109 /OUT pdfmark
        [ /Title (A.2.1 Integer literals) /Page 1109 /OUT pdfmark
        [ /Title (A.2.2 Floating-point-literals) /Page 1111 /OUT pdfmark
        [ /Title (A.2.3 Boolean literals) /Page 1111 /OUT pdfmark
        [ /Title (A.2.4 Character literals) /Page 1111 /OUT pdfmark
        [ /Title (A.2.5 String literals) /Page 1112 /OUT pdfmark
        [ /Title (A.2.6 The pointer literal) /Page 1113 /OUT pdfmark

      [ /Count -1 /Title (A.3 Identifiers) /Page 1113 /OUT pdfmark
        [ /Title (A.3.1 Keywords) /Page 1113 /OUT pdfmark

      [ /Count -3 /Title (A.4 Scope, storage class, and lifetime) /Page 1114 /OUT pdfmark
        [ /Title (A.4.1 Scope) /Page 1114 /OUT pdfmark
        [ /Title (A.4.2 Storage class) /Page 1115 /OUT pdfmark
        [ /Title (A.4.3 Lifetime) /Page 1117 /OUT pdfmark

      [ /Count -7 /Title (A.5 Expressions) /Page 1118 /OUT pdfmark
        [ /Title (A.5.1 User-defined operators) /Page 1123 /OUT pdfmark
        [ /Title (A.5.2 Implicit type conversion) /Page 1123 /OUT pdfmark
        [ /Title (A.5.3 Constant expressions) /Page 1125 /OUT pdfmark
        [ /Title (A.5.4 sizeof) /Page 1125 /OUT pdfmark
        [ /Title (A.5.5 Logical expressions) /Page 1126 /OUT pdfmark
        [ /Title (A.5.6 new and delete) /Page 1126 /OUT pdfmark
        [ /Title (A.5.7 Casts) /Page 1127 /OUT pdfmark

      [ /Title (A.6 Statements) /Page 1128 /OUT pdfmark
      [ /Count -1 /Title (A.7 Declarations) /Page 1130 /OUT pdfmark
        [ /Title (A.7.1 Definitions) /Page 1130 /OUT pdfmark

      [ /Count -3 /Title (A.8 Built-in types) /Page 1131 /OUT pdfmark
        [ /Title (A.8.1 Pointers) /Page 1132 /OUT pdfmark
        [ /Title (A.8.2 Arrays) /Page 1133 /OUT pdfmark
        [ /Title (A.8.3 References) /Page 1134 /OUT pdfmark

      [ /Count -4 /Title (A.9 Functions) /Page 1135 /OUT pdfmark
        [ /Title (A.9.1 Overload resolution) /Page 1136 /OUT pdfmark
        [ /Title (A.9.2 Default arguments) /Page 1137 /OUT pdfmark
        [ /Title (A.9.3 Unspecified arguments) /Page 1137 /OUT pdfmark
        [ /Title (A.9.4 Linkage specifications) /Page 1138 /OUT pdfmark

      [ /Count -1 /Title (A.10 User-defined types) /Page 1138 /OUT pdfmark
        [ /Title (A.10.1 Operator overloading) /Page 1139 /OUT pdfmark

      [ /Title (A.11 Enumerations) /Page 1139 /OUT pdfmark
      [ /Count -6 /Title (A.12 Classes) /Page 1140 /OUT pdfmark
        [ /Title (A.12.1 Member access) /Page 1140 /OUT pdfmark
        [ /Title (A.12.2 Class member definitions) /Page 1144 /OUT pdfmark
        [ /Title (A.12.3 Construction, destruction, and copy) /Page 1144 /OUT pdfmark
        [ /Title (A.12.4 Derived classes) /Page 1148 /OUT pdfmark
        [ /Title (A.12.5 Bitfields) /Page 1152 /OUT pdfmark
        [ /Title (A.12.6 Unions) /Page 1153 /OUT pdfmark

      [ /Count -3 /Title (A.13 Templates) /Page 1153 /OUT pdfmark
        [ /Title (A.13.1 Template arguments) /Page 1154 /OUT pdfmark
        [ /Title (A.13.2 Template instantiation) /Page 1155 /OUT pdfmark
        [ /Title (A.13.3 Template member types) /Page 1156 /OUT pdfmark

      [ /Title (A.14 Exceptions) /Page 1157 /OUT pdfmark
      [ /Title (A.15 Namespaces) /Page 1159 /OUT pdfmark
      [ /Title (A.16 Aliases) /Page 1160 /OUT pdfmark
      [ /Count -2 /Title (A.17 Preprocessor directives) /Page 1160 /OUT pdfmark
        [ /Title (A.17.1 #include) /Page 1160 /OUT pdfmark
        [ /Title (A.17.2 #define) /Page 1161 /OUT pdfmark


    [ /Count -12 /Title (Appendix B Standard Library Summary) /Page 1163 /OUT pdfmark
      [ /Count -3 /Title (B.1 Overview) /Page 1164 /OUT pdfmark
        [ /Title (B.1.1 Header files) /Page 1165 /OUT pdfmark
        [ /Title (B.1.2 Namespace std) /Page 1168 /OUT pdfmark
        [ /Title (B.1.3 Description style) /Page 1168 /OUT pdfmark

      [ /Count -1 /Title (B.2 Error handling) /Page 1169 /OUT pdfmark
        [ /Title (B.2.1 Exceptions) /Page 1170 /OUT pdfmark

      [ /Count -2 /Title (B.3 Iterators) /Page 1171 /OUT pdfmark
        [ /Title (B.3.1 Iterator model) /Page 1172 /OUT pdfmark
        [ /Title (B.3.2 Iterator categories) /Page 1174 /OUT pdfmark

      [ /Count -10 /Title (B.4 Containers) /Page 1176 /OUT pdfmark
        [ /Title (B.4.1 Overview) /Page 1178 /OUT pdfmark
        [ /Title (B.4.2 Member types) /Page 1179 /OUT pdfmark
        [ /Title (B.4.3 Constructors, destructors, and assignments) /Page 1180 /OUT pdfmark
        [ /Title (B.4.4 Iterators) /Page 1180 /OUT pdfmark
        [ /Title (B.4.5 Element access) /Page 1181 /OUT pdfmark
        [ /Title (B.4.6 Stack and queue operations) /Page 1181 /OUT pdfmark
        [ /Title (B.4.7 List operations) /Page 1182 /OUT pdfmark
        [ /Title (B.4.8 Size and capacity) /Page 1182 /OUT pdfmark
        [ /Title (B.4.9 Other operations) /Page 1183 /OUT pdfmark
        [ /Title (B.4.10 Associative container operations) /Page 1183 /OUT pdfmark

      [ /Count -8 /Title (B.5 Algorithms) /Page 1184 /OUT pdfmark
        [ /Title (B.5.1 Nonmodifying sequence algorithms) /Page 1185 /OUT pdfmark
        [ /Title (B.5.2 Modifying sequence algorithms) /Page 1186 /OUT pdfmark
        [ /Title (B.5.3 Utility algorithms) /Page 1188 /OUT pdfmark
        [ /Title (B.5.4 Sorting and searching) /Page 1189 /OUT pdfmark
        [ /Title (B.5.5 Set algorithms) /Page 1191 /OUT pdfmark
        [ /Title (B.5.6 Heaps) /Page 1192 /OUT pdfmark
        [ /Title (B.5.7 Permutations) /Page 1192 /OUT pdfmark
        [ /Title (B.5.8 min and max) /Page 1193 /OUT pdfmark

      [ /Count -5 /Title (B.6 STL utilities) /Page 1194 /OUT pdfmark
        [ /Title (B.6.1 Inserters) /Page 1194 /OUT pdfmark
        [ /Title (B.6.2 Function objects) /Page 1195 /OUT pdfmark
        [ /Title (B.6.3 pair and tuple) /Page 1197 /OUT pdfmark
        [ /Title (B.6.4 initializer_list) /Page 1198 /OUT pdfmark
        [ /Title (B.6.5 Resource management pointers) /Page 1199 /OUT pdfmark

      [ /Count -6 /Title (B.7 I/O streams) /Page 1200 /OUT pdfmark
        [ /Title (B.7.1 I/O streams hierarchy) /Page 1202 /OUT pdfmark
        [ /Title (B.7.2 Error handling) /Page 1203 /OUT pdfmark
        [ /Title (B.7.3 Input operations) /Page 1204 /OUT pdfmark
        [ /Title (B.7.4 Output operations) /Page 1205 /OUT pdfmark
        [ /Title (B.7.5 Formatting) /Page 1205 /OUT pdfmark
        [ /Title (B.7.6 Standard manipulators) /Page 1205 /OUT pdfmark

      [ /Count -3 /Title (B.8 String manipulation) /Page 1207 /OUT pdfmark
        [ /Title (B.8.1 Character classification) /Page 1207 /OUT pdfmark
        [ /Title (B.8.2 String) /Page 1208 /OUT pdfmark
        [ /Title (B.8.3 Regular expression matching) /Page 1209 /OUT pdfmark

      [ /Count -6 /Title (B.9 Numerics) /Page 1212 /OUT pdfmark
        [ /Title (B.9.1 Numerical limits) /Page 1212 /OUT pdfmark
        [ /Title (B.9.2 Standard mathematical functions) /Page 1213 /OUT pdfmark
        [ /Title (B.9.3 Complex) /Page 1214 /OUT pdfmark
        [ /Title (B.9.4 valarray) /Page 1215 /OUT pdfmark
        [ /Title (B.9.5 Generalized numerical algorithms) /Page 1215 /OUT pdfmark
        [ /Title (B.9.6 Random numbers) /Page 1216 /OUT pdfmark

      [ /Title (B.10 Time) /Page 1217 /OUT pdfmark
      [ /Count -6 /Title (B.11 C standard library functions) /Page 1217 /OUT pdfmark
        [ /Title (B.11.1 Files) /Page 1218 /OUT pdfmark
        [ /Title (B.11.2 The printf() family) /Page 1218 /OUT pdfmark
        [ /Title (B.11.3 C-style strings) /Page 1223 /OUT pdfmark
        [ /Title (B.11.4 Memory) /Page 1224 /OUT pdfmark
        [ /Title (B.11.5 Date and time) /Page 1225 /OUT pdfmark
        [ /Title (B.10.6 Etc.) /Page 1226 /OUT pdfmark

      [ /Title (B.12 Other libraries) /Page 1227 /OUT pdfmark

    [ /Count -4 /Title (Appendix C Getting Started with Visual Studio) /Page 1229 /OUT pdfmark
      [ /Title (C.1 Getting a program to run) /Page 1230 /OUT pdfmark
      [ /Title (C.2 Installing Visual Studio) /Page 1230 /OUT pdfmark
      [ /Count -7 /Title (C.3 Creating and running a program) /Page 1231 /OUT pdfmark
        [ /Title (C.3.1 Create a new project) /Page 1231 /OUT pdfmark
        [ /Title (C.3.2 Use the std_lib_facilities.h header file) /Page 1231 /OUT pdfmark
        [ /Title (C.3.3 Add a C++ source file to the project) /Page 1232 /OUT pdfmark
        [ /Title (C.3.4 Enter your source code) /Page 1232 /OUT pdfmark
        [ /Title (C.3.5 Build an executable program) /Page 1232 /OUT pdfmark
        [ /Title (C.3.6 Execute the program) /Page 1233 /OUT pdfmark
        [ /Title (C.3.7 Save the program) /Page 1233 /OUT pdfmark

      [ /Title (C.4 Later) /Page 1233 /OUT pdfmark

    [ /Count -5 /Title (Appendix D Installing FLTK) /Page 1235 /OUT pdfmark
      [ /Title (D.1 Introduction) /Page 1236 /OUT pdfmark
      [ /Title (D.2 Downloading FLTK) /Page 1236 /OUT pdfmark
      [ /Title (D.3 Installing FLTK) /Page 1237 /OUT pdfmark
      [ /Title (D.4 Using FLTK in Visual Studio) /Page 1237 /OUT pdfmark
      [ /Title (D.5 Testing if it all worked) /Page 1238 /OUT pdfmark

    [ /Count -5 /Title (Appendix E GUI Implementation) /Page 1239 /OUT pdfmark
      [ /Title (E.1 Callback implementation) /Page 1240 /OUT pdfmark
      [ /Title (E.2 Widget implementation) /Page 1241 /OUT pdfmark
      [ /Title (E.3 Window implementation) /Page 1242 /OUT pdfmark
      [ /Title (E.4 Vector_ref) /Page 1244 /OUT pdfmark
      [ /Title (E.5 An example: manipulating Widgets) /Page 1245 /OUT pdfmark


  [ /Title (Glossary) /Page 1249 /OUT pdfmark
  [ /Title (Bibliography) /Page 1255 /OUT pdfmark
  [ /Title (Index) /Page 1259 /OUT pdfmark
